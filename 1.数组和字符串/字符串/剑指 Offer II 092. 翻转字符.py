"""
如果一个由'0' 和 '1'组成的字符串，是以一些 '0'（可能没有 '0'）后面跟着一些 '1'（也可能没有 '1'）的形式组成的，那么该字符串是单调递增的。

我们给出一个由字符 '0' 和 '1'组成的字符串 s，我们可以将任何'0' 翻转为'1'或者将'1'翻转为'0'。

返回使 s单调递增的最小翻转次数。



示例 1：

输入：s = "00110"
输出：1
解释：我们翻转最后一位得到 00111.
示例 2：

输入：s = "010110"
输出：2
解释：我们翻转得到 011111，或者是 000111。
示例 3：

输入：s = "00011000"
输出：2
解释：我们翻转得到 00000000。


提示：

1 <= s.length <= 20000
s 中只包含字符'0'和'1'


来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/cyJERH
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
"""


class Solution:
    def minFlipsMonoIncr(self, s: str) -> int:
        n = len(s)
        # 求出0和1的个数
        cnt0, cnt1 = s.count('0'), s.count('1')
        # 极限情况下，全部1变成0，全部0变成1
        ans = min(cnt0, cnt1)
        # 索引左边1的个数
        left1 = 0
        # 索引右边（包含索引）0的个数
        right0 = cnt0
        for i in range(n):
            # 左边的全变成0，右边的全变成1，换句话说，索引之前的为0，索引之后（包含自己）为1
            ans = min(ans, right0 + left1)

            if s[i] == '0':
                # 如果当前元素为0，为下一步做准备，右侧的0的个数减1
                right0 -= 1
            elif s[i] == '1':
                # 如果当前元素为1，为下一步做准备，左侧的0的个数加1
                left1 += 1
        ans = min(ans, right0 + left1)
        return ans
